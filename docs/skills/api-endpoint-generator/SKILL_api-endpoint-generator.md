---
name: api-endpoint-generator
description: >
  Generates complete API endpoint implementations following the project's repository â†’ 
  service â†’ route pattern. Use when: user says "create endpoint", "add API for", "build 
  the backend for", or when implementing a feature that requires a new API endpoint. 
  Generates all layers: shared types, Zod validation, repository, service, route handler, 
  and route mounting. Also updates API.md documentation. Always read existing code patterns 
  before generating â€” consistency with the existing codebase is critical.
---

# API Endpoint Generator

## Purpose

Generate complete, pattern-consistent API endpoint implementations across all application layers. Every endpoint generated by this skill includes types, validation, data access, business logic, HTTP handling, and documentation.

## Pre-Generation Checklist

Before generating any code:

1. **Read existing routes** â€” Match patterns, naming conventions, error handling style
2. **Check shared types** â€” Reuse existing interfaces where possible
3. **Verify database tables** â€” Confirm the table exists or note that a migration is needed
4. **Check API.md** â€” Ensure this endpoint isn't already documented (avoid duplication)
5. **Review REQUIREMENTS.md** â€” Understand the acceptance criteria this endpoint serves

## File Generation Order

Always create/modify files in this exact order:

```
1. packages/shared/src/types/index.ts      â†’ TypeScript interfaces
2. packages/shared/src/validation/index.ts  â†’ Zod validation schemas
3. packages/api/src/repositories/[domain]Repo.ts â†’ Data access (Knex.js)
4. packages/api/src/services/[domain]Service.ts  â†’ Business logic
5. packages/api/src/routes/[domain].ts      â†’ Express route handler
6. packages/api/src/routes/index.ts         â†’ Mount the route
7. docs/API.md                              â†’ Documentation
```

## Layer Patterns

### 1. Shared Types (TypeScript Interfaces)

```typescript
// packages/shared/src/types/index.ts

export interface CreateItemRequest {
  name: string;
  categoryId: number;
  quantity?: number;
}

export interface ItemResponse {
  id: number;
  name: string;
  category: string;
  quantity: number;
  createdAt: string;
  updatedAt: string;
}

export interface ItemListResponse {
  items: ItemResponse[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}
```

### 2. Zod Validation Schemas

```typescript
// packages/shared/src/validation/index.ts
import { z } from 'zod';

export const createItemSchema = z.object({
  name: z.string().min(1).max(255),
  categoryId: z.number().int().positive(),
  quantity: z.number().int().min(0).optional().default(1),
});

export const itemQuerySchema = z.object({
  page: z.coerce.number().int().min(1).optional().default(1),
  limit: z.coerce.number().int().min(1).max(50).optional().default(20),
  sort: z.enum(['newest', 'name', 'category']).optional().default('newest'),
  q: z.string().optional(),
});
```

### 3. Repository (Data Access)

```typescript
// packages/api/src/repositories/itemRepo.ts
import { db } from '../config/database';

export const itemRepo = {
  async findAll(options: { page: number; limit: number; sort: string; query?: string }) {
    const { page, limit, sort, query } = options;
    const offset = (page - 1) * limit;

    let baseQuery = db('items').where('is_deleted', false);
    
    if (query) {
      baseQuery = baseQuery.where('name', 'like', `%${query}%`);
    }

    const [items, [{ total }]] = await Promise.all([
      baseQuery.clone()
        .orderBy(sort === 'newest' ? 'created_at' : sort, 'desc')
        .offset(offset)
        .limit(limit),
      baseQuery.clone().count('* as total'),
    ]);

    return { items, total: Number(total) };
  },

  async findById(id: number) {
    return db('items').where({ id, is_deleted: false }).first();
  },

  async create(data: { name: string; categoryId: number; quantity: number }) {
    const [result] = await db('items').insert({
      name: data.name,
      category_id: data.categoryId,
      quantity: data.quantity,
      created_at: db.fn.now(),
      updated_at: db.fn.now(),
    }).returning('id');
    return result;
  },

  async update(id: number, data: Partial<{ name: string; categoryId: number; quantity: number }>) {
    return db('items').where({ id }).update({
      ...data,
      updated_at: db.fn.now(),
    });
  },

  async softDelete(id: number) {
    return db('items').where({ id }).update({ is_deleted: true, updated_at: db.fn.now() });
  },
};
```

**Repository Rules:**
- Use Knex.js for ALL queries (no raw SQL unless absolutely necessary)
- Return plain objects, never Knex query builders
- Handle SQL Server specifics (TOP vs LIMIT handled by Knex automatically)
- Always use parameterized queries (Knex does this by default)
- Use snake_case for database columns, camelCase for JS/TS properties
- Implement soft delete by default (is_deleted flag)

### 4. Service (Business Logic)

```typescript
// packages/api/src/services/itemService.ts
import { itemRepo } from '../repositories/itemRepo';
import { createItemSchema, itemQuerySchema } from '@foodgenie/shared/validation';

export const itemService = {
  async list(query: unknown) {
    const validated = itemQuerySchema.parse(query);
    const { items, total } = await itemRepo.findAll(validated);
    
    return {
      items: items.map(formatItem),
      total,
      page: validated.page,
      limit: validated.limit,
      totalPages: Math.ceil(total / validated.limit),
    };
  },

  async getById(id: number) {
    const item = await itemRepo.findById(id);
    if (!item) throw new NotFoundError('Item not found');
    return formatItem(item);
  },

  async create(data: unknown, userId: number) {
    const validated = createItemSchema.parse(data);
    const result = await itemRepo.create(validated);
    return { id: result.id };
  },
};

function formatItem(row: any) {
  return {
    id: row.id,
    name: row.name,
    category: row.category_name,
    quantity: row.quantity,
    createdAt: row.created_at,
    updatedAt: row.updated_at,
  };
}
```

**Service Rules:**
- ALL business logic lives here (not in routes, not in repositories)
- Validate inputs with Zod schemas at the service boundary
- Throw typed errors: `NotFoundError`, `ValidationError`, `ForbiddenError`
- Format database rows into API response shapes (snake_case â†’ camelCase)
- Orchestrate multiple repository calls when needed

### 5. Route Handler (HTTP Layer)

```typescript
// packages/api/src/routes/items.ts
import { Router } from 'express';
import { itemService } from '../services/itemService';
import { requireAuth } from '../middleware/auth';

const router = Router();

// GET /api/items â€” List items (public)
router.get('/', async (req, res, next) => {
  try {
    const result = await itemService.list(req.query);
    res.json({ success: true, data: result.items, meta: { 
      page: result.page, limit: result.limit, total: result.total, totalPages: result.totalPages 
    }});
  } catch (err) { next(err); }
});

// GET /api/items/:id â€” Get item detail (public)
router.get('/:id', async (req, res, next) => {
  try {
    const item = await itemService.getById(Number(req.params.id));
    res.json({ success: true, data: item });
  } catch (err) { next(err); }
});

// POST /api/items â€” Create item (authenticated)
router.post('/', requireAuth, async (req, res, next) => {
  try {
    const result = await itemService.create(req.body, req.user!.id);
    res.status(201).json({ success: true, data: result });
  } catch (err) { next(err); }
});

export default router;
```

**Route Rules:**
- Routes handle HTTP concerns ONLY (parse request, format response, set status code)
- NO business logic in routes
- Use try/catch with next(err) for centralized error handling
- Apply auth middleware where needed: `requireAuth`, `requireRole('admin')`
- Use standard response envelope: `{ success: true, data: {...}, meta: {...} }`

### 6. Route Mounting

```typescript
// packages/api/src/routes/index.ts
import items from './items';

router.use('/items', items);  // Add new route mount
```

### 7. API Documentation

Add to docs/API.md:

```markdown
## Items (Sprint X.Y)

| Method | Path | Auth | Description |
|--------|------|------|-------------|
| GET | `/api/items` | â€” | List items with pagination and search |
| GET | `/api/items/:id` | â€” | Get item detail |
| POST | `/api/items` | ðŸ”’ | Create new item |

### GET /api/items â€” Query Params
| Param | Type | Default | Description |
|-------|------|---------|-------------|
| page | number | 1 | Page number |
| limit | number | 20 | Items per page (max 50) |
| sort | string | newest | Sort: newest, name, category |
| q | string | â€” | Text search |
```

## Standard Response Envelope

All endpoints MUST use this format:

```json
// Success
{ "success": true, "data": { ... }, "meta": { "page": 1, "limit": 20, "total": 150, "totalPages": 8 } }

// Success (single item)
{ "success": true, "data": { ... } }

// Error
{ "success": false, "error": { "code": "VALIDATION_ERROR", "message": "...", "details": { ... } } }
```

## Error Codes

| Code | HTTP Status | When |
|------|-------------|------|
| VALIDATION_ERROR | 400 | Zod validation failed |
| UNAUTHORIZED | 401 | Not authenticated |
| FORBIDDEN | 403 | Insufficient role |
| NOT_FOUND | 404 | Resource doesn't exist |
| CONFLICT | 409 | Duplicate (email, username) |
| RATE_LIMITED | 429 | Too many requests |
| INTERNAL_ERROR | 500 | Unexpected server error |
