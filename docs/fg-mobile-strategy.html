<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FoodGenie: Mobile Strategy & Full-Stack Decision</title>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Instrument+Serif&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #faf9f7;
    --surface: #ffffff;
    --surface-alt: #f3f1ed;
    --border: #e2dfd8;
    --border-strong: #c9c4b9;
    --text: #1a1815;
    --text-dim: #6b6560;
    --text-muted: #9b9590;
    --node-green: #16a34a;
    --node-green-bg: #f0fdf4;
    --node-green-border: #bbf7d0;
    --laravel-red: #dc2626;
    --laravel-red-bg: #fef2f2;
    --laravel-red-border: #fecaca;
    --accent-blue: #2563eb;
    --accent-blue-bg: #eff6ff;
    --accent-amber: #d97706;
    --accent-amber-bg: #fffbeb;
    --winner-bg: linear-gradient(135deg, #f0fdf4 0%, #ecfdf5 50%, #f0fdf4 100%);
    --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
    --shadow-md: 0 4px 12px rgba(0,0,0,0.06);
    --shadow-lg: 0 8px 24px rgba(0,0,0,0.08);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'DM Sans', -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.7;
    -webkit-font-smoothing: antialiased;
  }

  .page { max-width: 960px; margin: 0 auto; padding: 0 2rem; }

  /* HEADER */
  header {
    padding: 3.5rem 0 2.5rem;
    border-bottom: 2px solid var(--text);
  }
  header .tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    font-weight: 600;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 0.75rem;
  }
  header h1 {
    font-family: 'Instrument Serif', serif;
    font-size: 2.6rem;
    font-weight: 400;
    line-height: 1.15;
    letter-spacing: -0.02em;
  }
  header .lede {
    margin-top: 1rem;
    font-size: 1.05rem;
    color: var(--text-dim);
    max-width: 680px;
  }

  /* SECTIONS */
  .section {
    padding: 2.5rem 0;
    border-bottom: 1px solid var(--border);
  }
  .section:last-of-type { border-bottom: none; }
  .section-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
  }
  .section h2 {
    font-family: 'Instrument Serif', serif;
    font-size: 1.75rem;
    font-weight: 400;
    margin-bottom: 1.25rem;
  }
  .section h3 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.82rem;
    font-weight: 600;
    letter-spacing: 0.04em;
    color: var(--text-dim);
    margin: 1.75rem 0 0.75rem;
    text-transform: uppercase;
  }
  .section p { margin-bottom: 1rem; color: var(--text); font-size: 0.95rem; }
  .section p.dim { color: var(--text-dim); }

  /* CARDS */
  .card-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin: 1.25rem 0;
  }
  .card-grid-3 {
    grid-template-columns: 1fr 1fr 1fr;
  }
  .card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.25rem 1.5rem;
    box-shadow: var(--shadow-sm);
  }
  .card.highlight-green {
    background: var(--node-green-bg);
    border-color: var(--node-green-border);
  }
  .card.highlight-red {
    background: var(--laravel-red-bg);
    border-color: var(--laravel-red-border);
  }
  .card.highlight-blue {
    background: var(--accent-blue-bg);
    border-color: #bfdbfe;
  }
  .card.highlight-amber {
    background: var(--accent-amber-bg);
    border-color: #fde68a;
  }
  .card .card-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-bottom: 0.5rem;
  }
  .card .card-label.green { color: var(--node-green); }
  .card .card-label.red { color: var(--laravel-red); }
  .card .card-label.blue { color: var(--accent-blue); }
  .card .card-label.amber { color: var(--accent-amber); }
  .card .card-title {
    font-weight: 700;
    font-size: 1rem;
    margin-bottom: 0.5rem;
  }
  .card .card-text {
    font-size: 0.88rem;
    color: var(--text-dim);
    line-height: 1.6;
  }

  /* TABLE */
  .comp-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.88rem;
    margin: 1.25rem 0;
  }
  .comp-table thead th {
    text-align: left;
    padding: 0.75rem 1rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    font-weight: 600;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--text-muted);
    border-bottom: 2px solid var(--border-strong);
    background: var(--surface-alt);
  }
  .comp-table tbody td {
    padding: 0.7rem 1rem;
    border-bottom: 1px solid var(--border);
    vertical-align: top;
    line-height: 1.55;
  }
  .comp-table tbody tr:hover { background: var(--surface-alt); }
  .badge {
    display: inline-block;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    font-weight: 600;
    padding: 0.15rem 0.5rem;
    border-radius: 4px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .badge.yes { background: #dcfce7; color: #15803d; }
  .badge.no { background: #fee2e2; color: #dc2626; }
  .badge.partial { background: #fef3c7; color: #b45309; }
  .badge.best { background: #dbeafe; color: #1d4ed8; }

  /* CODE */
  .code-panel {
    background: #1e1e2e;
    border-radius: 8px;
    overflow: hidden;
    margin: 1.25rem 0;
    box-shadow: var(--shadow-md);
  }
  .code-panel-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.65rem 1rem;
    background: #181825;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.72rem;
    font-weight: 600;
    color: #a6adc8;
  }
  .code-panel-header .dot {
    width: 7px; height: 7px; border-radius: 50%;
  }
  .code-panel-header .dot.g { background: #a6e3a1; }
  .code-panel-header .dot.r { background: #f38ba8; }
  .code-panel-header .dot.y { background: #f9e2af; }
  .code-panel pre {
    padding: 1.1rem 1.25rem;
    overflow-x: auto;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.76rem;
    line-height: 1.75;
    color: #cdd6f4;
  }
  .code-panel pre .cm { color: #6c7086; font-style: italic; }
  .code-panel pre .kw { color: #cba6f7; }
  .code-panel pre .st { color: #a6e3a1; }
  .code-panel pre .fn { color: #89b4fa; }
  .code-panel pre .tp { color: #f9e2af; }
  .code-panel pre .op { color: #89dceb; }
  .code-panel pre .nb { color: #fab387; }

  /* VERDICT */
  .verdict {
    background: var(--winner-bg);
    border: 2px solid var(--node-green);
    border-radius: 12px;
    padding: 2rem 2.25rem;
    margin: 2rem 0;
    position: relative;
  }
  .verdict::before {
    content: 'FINAL VERDICT';
    position: absolute;
    top: -10px;
    left: 1.5rem;
    background: var(--bg);
    padding: 0 0.75rem;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.68rem;
    letter-spacing: 0.15em;
    color: var(--node-green);
    font-weight: 700;
  }
  .verdict h3 {
    font-family: 'Instrument Serif', serif;
    font-size: 1.5rem;
    font-weight: 400;
    margin-bottom: 1rem;
    text-transform: none;
    letter-spacing: normal;
    color: var(--text);
  }
  .verdict p { font-size: 0.92rem; color: var(--text-dim); margin-bottom: 0.75rem; }

  /* STACK TABLE */
  .stack-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1rem 0;
    font-size: 0.88rem;
  }
  .stack-table td {
    padding: 0.55rem 0;
    border-bottom: 1px solid var(--border);
  }
  .stack-table td:first-child {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    font-weight: 500;
    color: var(--text-muted);
    width: 150px;
    white-space: nowrap;
  }
  .stack-table td:nth-child(2) { font-weight: 600; }
  .stack-table td:nth-child(3) { color: var(--text-dim); font-size: 0.85rem; }

  /* DIAGRAM */
  .architecture-diagram {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    padding: 2rem;
    margin: 1.5rem 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.78rem;
    line-height: 1.8;
    overflow-x: auto;
    box-shadow: var(--shadow-sm);
  }
  .architecture-diagram pre {
    color: var(--text);
    white-space: pre;
  }
  .architecture-diagram .layer-label {
    color: var(--text-muted);
    font-size: 0.68rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  /* CALLOUT */
  .callout {
    background: var(--surface);
    border-left: 3px solid var(--accent-blue);
    padding: 1rem 1.25rem;
    margin: 1.25rem 0;
    border-radius: 0 6px 6px 0;
    font-size: 0.9rem;
  }
  .callout.warn { border-left-color: var(--accent-amber); }
  .callout.success { border-left-color: var(--node-green); }
  .callout strong { font-weight: 700; }

  .footer {
    padding: 2.5rem 0;
    text-align: center;
    font-size: 0.8rem;
    color: var(--text-muted);
  }

  @media (max-width: 768px) {
    .card-grid, .card-grid-3 { grid-template-columns: 1fr; }
    header h1 { font-size: 2rem; }
  }
</style>
</head>
<body>

<div class="page">

  <header>
    <div class="tag">FoodGenie · Architecture Decision Record</div>
    <h1>Mobile Strategy & Full-Stack Decision</h1>
    <p class="lede">How the Bluetooth scale, camera access, and native device requirements shape the entire technology stack — from backend to mobile to IoT.</p>
  </header>

  <!-- SECTION 1: WHY MOBILE CHANGES EVERYTHING -->
  <div class="section">
    <div class="section-num">01 — The Mobile Constraint</div>
    <h2>Bluetooth Kills Three Options Immediately</h2>

    <p>FoodGenie's planned features require native device APIs that narrow the mobile framework options dramatically. Here's what each feature demands:</p>

    <table class="comp-table">
      <thead>
        <tr>
          <th>Device Feature</th>
          <th>PWA (Web Browser)</th>
          <th>Capacitor/Ionic</th>
          <th>React Native</th>
          <th>Flutter</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Camera (receipt/barcode)</strong></td>
          <td><span class="badge partial">Limited</span> Basic capture only</td>
          <td><span class="badge yes">Yes</span> Via plugin</td>
          <td><span class="badge yes">Yes</span> Full control</td>
          <td><span class="badge yes">Yes</span> Full control</td>
        </tr>
        <tr>
          <td><strong>Barcode Scanning</strong></td>
          <td><span class="badge partial">Limited</span> JS libs, slow</td>
          <td><span class="badge yes">Yes</span> Via plugin</td>
          <td><span class="badge yes">Yes</span> react-native-camera</td>
          <td><span class="badge yes">Yes</span> mobile_scanner</td>
        </tr>
        <tr>
          <td><strong>Bluetooth Low Energy (Scale)</strong></td>
          <td><span class="badge no">No</span> Not on iOS Safari</td>
          <td><span class="badge partial">Partial</span> Plugin exists, community maintained</td>
          <td><span class="badge yes">Yes</span> react-native-ble-plx (proven)</td>
          <td><span class="badge yes">Yes</span> flutter_blue_plus</td>
        </tr>
        <tr>
          <td><strong>Background BLE (scale auto-sync)</strong></td>
          <td><span class="badge no">No</span></td>
          <td><span class="badge no">No</span> Web container limit</td>
          <td><span class="badge yes">Yes</span> Native modules</td>
          <td><span class="badge yes">Yes</span> Native plugins</td>
        </tr>
        <tr>
          <td><strong>Push Notifications</strong></td>
          <td><span class="badge partial">Partial</span> No iOS Safari</td>
          <td><span class="badge yes">Yes</span></td>
          <td><span class="badge yes">Yes</span></td>
          <td><span class="badge yes">Yes</span></td>
        </tr>
        <tr>
          <td><strong>Offline Mode (recipes/meal plan)</strong></td>
          <td><span class="badge partial">Partial</span> Service Worker</td>
          <td><span class="badge partial">Partial</span></td>
          <td><span class="badge yes">Yes</span> AsyncStorage + SQLite</td>
          <td><span class="badge yes">Yes</span> Hive/Isar</td>
        </tr>
        <tr>
          <td><strong>App Store Distribution</strong></td>
          <td><span class="badge no">No</span></td>
          <td><span class="badge yes">Yes</span></td>
          <td><span class="badge yes">Yes</span></td>
          <td><span class="badge yes">Yes</span></td>
        </tr>
      </tbody>
    </table>

    <div class="callout warn">
      <strong>Critical finding:</strong> Apple's iOS Safari does not support the Web Bluetooth API and has shown no intent to implement it. Any FoodGenie feature requiring Bluetooth communication with a physical scale <strong>must</strong> use a native mobile framework. PWA and Capacitor/Ionic cannot reliably deliver this on iPhones.
    </div>

    <p>This eliminates PWA-only and Capacitor/Ionic from consideration for the mobile app. <strong>FoodGenie needs React Native or Flutter.</strong></p>
  </div>

  <!-- SECTION 2: REACT NATIVE vs FLUTTER -->
  <div class="section">
    <div class="section-num">02 — Mobile Framework: React Native vs Flutter</div>
    <h2>The Language Unification Argument</h2>

    <p>Here's where the backend stack decision and the mobile framework decision converge into a single question:</p>

    <div class="card-grid">
      <div class="card highlight-green">
        <div class="card-label green">All-JavaScript Stack</div>
        <div class="card-title">Node.js + React + React Native</div>
        <div class="card-text">
          One language (TypeScript) across backend, web, and mobile. Shared types, shared API client, shared validation logic, shared utility functions. A developer working on the web app can contribute to the mobile app without learning a new language. The BLE scale integration uses <code>react-native-ble-plx</code>, the most proven BLE library in the React Native ecosystem.
        </div>
      </div>
      <div class="card highlight-amber">
        <div class="card-label amber">Mixed Stack</div>
        <div class="card-title">Laravel (PHP) + React + Flutter (Dart)</div>
        <div class="card-text">
          Three languages across the stack: PHP for backend, TypeScript for web, Dart for mobile. No type sharing between layers. API contracts must be manually synchronized. A backend change requires updating the web client AND the mobile client in different languages. Flutter's BLE support is good via <code>flutter_blue_plus</code>, but you'd need to learn Dart.
        </div>
      </div>
    </div>

    <p>If you choose Laravel for the backend, you'd still likely use React Native for mobile (since your web app is React and the knowledge transfers). That gives you PHP + TypeScript + TypeScript — two languages instead of one. Workable, but you lose the shared-types advantage between backend and clients.</p>

    <h3>What "Shared Types" Actually Means for FoodGenie</h3>

    <div class="code-panel">
      <div class="code-panel-header">
        <span class="dot g"></span><span class="dot y"></span><span class="dot r"></span>
        shared/types/recipe.ts — Used by backend, web, AND mobile
      </div>
      <pre><span class="cm">// This file lives in a shared package used by ALL three layers</span>
<span class="cm">// Backend validates against it, web renders from it, mobile displays it</span>

<span class="kw">export interface</span> <span class="tp">Recipe</span> {
  id: <span class="tp">number</span>;
  title: <span class="tp">string</span>;
  slug: <span class="tp">string</span>;
  description: <span class="tp">string</span>;
  prepTime: <span class="tp">number</span>;        <span class="cm">// minutes</span>
  cookTime: <span class="tp">number</span>;        <span class="cm">// minutes</span>
  servings: <span class="tp">number</span>;
  difficulty: <span class="st">'easy'</span> | <span class="st">'medium'</span> | <span class="st">'hard'</span>;
  ingredients: <span class="tp">RecipeIngredient</span>[];
  steps: <span class="tp">RecipeStep</span>[];
  nutrition: <span class="tp">NutritionInfo</span> | <span class="kw">null</span>;
  coverage?: <span class="tp">number</span>;       <span class="cm">// 0-1, how much user has in inventory</span>
  missingItems?: <span class="tp">IngredientSummary</span>[];
}

<span class="kw">export interface</span> <span class="tp">RecipeIngredient</span> {
  id: <span class="tp">number</span>;
  canonicalId: <span class="tp">number</span>;     <span class="cm">// links to food taxonomy</span>
  name: <span class="tp">string</span>;            <span class="cm">// display name: "all-purpose flour"</span>
  quantity: <span class="tp">number</span>;
  unit: <span class="tp">string</span>;            <span class="cm">// "cups", "tbsp", "g"</span>
  prepState?: <span class="tp">string</span>;      <span class="cm">// "diced", "melted"</span>
  isOptional: <span class="tp">boolean</span>;
  inInventory: <span class="tp">InventoryMatch</span>;  <span class="cm">// green/orange/red</span>
  substitutes: <span class="tp">SubstituteOption</span>[];
}

<span class="kw">export type</span> <span class="tp">InventoryMatch</span> = <span class="st">'exact'</span> | <span class="st">'substitute'</span> | <span class="st">'missing'</span>;
<span class="cm">// 'exact'      → green  (user has this item)</span>
<span class="cm">// 'substitute'  → orange (user has a compatible item)</span>
<span class="cm">// 'missing'     → red    (not in inventory)</span>

<span class="kw">export interface</span> <span class="tp">ScaleReading</span> {
  weight: <span class="tp">number</span>;          <span class="cm">// grams</span>
  unit: <span class="st">'g'</span> | <span class="st">'oz'</span> | <span class="st">'lb'</span> | <span class="st">'kg'</span>;
  deviceId: <span class="tp">string</span>;        <span class="cm">// BLE device identifier</span>
  timestamp: <span class="tp">Date</span>;
  stable: <span class="tp">boolean</span>;         <span class="cm">// reading has settled</span>
}</pre>
    </div>

    <p>With an all-TypeScript stack, this file is imported directly by the Express API (for validation), the React web app (for rendering), and the React Native mobile app (for display and BLE data handling). With a PHP backend, you'd define these types in PHP AND in TypeScript — two sources of truth that can drift apart.</p>
  </div>

  <!-- SECTION 3: THE BLE SCALE DEEP DIVE -->
  <div class="section">
    <div class="section-num">03 — The Bluetooth Scale Integration</div>
    <h2>How the Smart Scale Workflow Maps to React Native</h2>

    <p>Let me sketch the actual user experience and technical flow for the BLE food scale, because this is a differentiating feature:</p>

    <div class="architecture-diagram">
      <pre><span class="layer-label">USER FLOW: WEIGHING INGREDIENTS WHILE COOKING</span>

  ┌─────────────────────┐     BLE GATT      ┌──────────────────┐
  │   FoodGenie Scale    │ ◄──────────────►  │  React Native    │
  │   (BLE Peripheral)   │  Weight Service   │  Mobile App      │
  │                      │  Char: 0x2A9D     │                  │
  │  • Tare button       │                   │  • Live weight   │
  │  • Weight sensor     │                   │  • Unit toggle   │
  │  • Battery level     │                   │  • Tare command  │
  └─────────────────────┘                    │  • Ingredient    │
                                             │    assignment    │
                                             └────────┬─────────┘
                                                      │
                                                 REST API
                                                      │
                                             ┌────────▼─────────┐
                                             │  Node.js API      │
                                             │                   │
                                             │  POST /inventory  │
                                             │    /weigh         │
                                             │                   │
                                             │  • Convert units  │
                                             │  • Update qty     │
                                             │  • Recalc recipes │
                                             │  • Nutrition calc │
                                             └───────────────────┘

<span class="layer-label">SCENARIO: USER WEIGHS CHICKEN BREAST</span>

  1. User opens recipe "Chicken Parmesan" on phone
  2. App shows ingredient: "8 oz chicken breast" (red — not in inventory)
  3. User taps "Weigh" button next to ingredient
  4. App connects to paired FoodGenie Scale via BLE
  5. Scale streams weight readings → app shows live: "7.8 oz... 8.1 oz... 8.0 oz ✓"
  6. Reading stabilizes → app confirms: "8.0 oz chicken breast"
  7. User taps "Add to Kitchen" → API updates inventory
  8. Ingredient turns green → recipe coverage recalculates
  9. Nutrition auto-calculates based on actual weight measured</pre>
    </div>

    <div class="code-panel">
      <div class="code-panel-header">
        <span class="dot g"></span><span class="dot y"></span><span class="dot r"></span>
        React Native — BLE Scale Service (react-native-ble-plx)
      </div>
      <pre><span class="cm">// services/bleScale.ts — React Native mobile app</span>
<span class="kw">import</span> { BleManager, Device } <span class="kw">from</span> <span class="st">'react-native-ble-plx'</span>;
<span class="kw">import</span> <span class="kw">type</span> { <span class="tp">ScaleReading</span> } <span class="kw">from</span> <span class="st">'@foodgenie/shared-types'</span>;

<span class="kw">const</span> SCALE_SERVICE_UUID = <span class="st">'0000181d-0000-1000-8000-00805f9b34fb'</span>; <span class="cm">// Weight Scale</span>
<span class="kw">const</span> WEIGHT_CHAR_UUID   = <span class="st">'00002a9d-0000-1000-8000-00805f9b34fb'</span>; <span class="cm">// Weight Measurement</span>

<span class="kw">export class</span> <span class="tp">FoodGenieScale</span> {
  <span class="kw">private</span> manager: <span class="tp">BleManager</span>;
  <span class="kw">private</span> device: <span class="tp">Device</span> | <span class="kw">null</span> = <span class="kw">null</span>;

  <span class="kw">constructor</span>() {
    <span class="kw">this</span>.manager = <span class="kw">new</span> <span class="fn">BleManager</span>();
  }

  <span class="kw">async</span> <span class="fn">scan</span>(): <span class="tp">Promise</span><<span class="tp">Device</span>[]> {
    <span class="kw">const</span> devices: <span class="tp">Device</span>[] = [];
    <span class="kw">this</span>.manager.<span class="fn">startDeviceScan</span>(
      [SCALE_SERVICE_UUID],
      <span class="kw">null</span>,
      (error, device) => {
        <span class="kw">if</span> (device?.name?.<span class="fn">includes</span>(<span class="st">'FoodGenie'</span>)) {
          devices.<span class="fn">push</span>(device);
        }
      }
    );
    <span class="kw">await</span> <span class="kw">new</span> <span class="tp">Promise</span>(r => <span class="fn">setTimeout</span>(r, <span class="nb">5000</span>));
    <span class="kw">this</span>.manager.<span class="fn">stopDeviceScan</span>();
    <span class="kw">return</span> devices;
  }

  <span class="kw">async</span> <span class="fn">connect</span>(deviceId: <span class="tp">string</span>): <span class="tp">Promise</span><<span class="kw">void</span>> {
    <span class="kw">this</span>.device = <span class="kw">await</span> <span class="kw">this</span>.manager.<span class="fn">connectToDevice</span>(deviceId);
    <span class="kw">await</span> <span class="kw">this</span>.device.<span class="fn">discoverAllServicesAndCharacteristics</span>();
  }

  <span class="cm">// Stream weight readings to a callback</span>
  <span class="fn">onWeightChange</span>(callback: (reading: <span class="tp">ScaleReading</span>) => <span class="kw">void</span>): <span class="kw">void</span> {
    <span class="kw">this</span>.device?.<span class="fn">monitorCharacteristicForService</span>(
      SCALE_SERVICE_UUID,
      WEIGHT_CHAR_UUID,
      (error, char) => {
        <span class="kw">if</span> (char?.value) {
          <span class="kw">const</span> data = <span class="fn">parseWeightData</span>(char.value);
          <span class="fn">callback</span>({
            weight: data.weight,
            unit: data.unit,
            deviceId: <span class="kw">this</span>.device!.id,
            timestamp: <span class="kw">new</span> <span class="tp">Date</span>(),
            stable: data.stable
          });
        }
      }
    );
  }
}</pre>
    </div>

    <p class="dim">This React Native BLE code shares the <code>ScaleReading</code> type with the Node.js API. When the scale reading is sent to the server, the API validates against the same interface. No translation layer, no type drift.</p>
  </div>

  <!-- SECTION 4: RESPONSIVE DESIGN -->
  <div class="section">
    <div class="section-num">04 — Responsive Design: Backend Doesn't Matter</div>
    <h2>Both Stacks Use React — Design Quality Is Identical</h2>

    <p>To directly answer your first question: the backend language has <strong>zero impact</strong> on responsive layouts and design patterns. Here's why:</p>

    <div class="card-grid card-grid-3">
      <div class="card">
        <div class="card-label blue">Web App</div>
        <div class="card-title">React + Tailwind CSS</div>
        <div class="card-text">Same framework, same responsive utilities, same design system regardless of whether the API is Node.js or Laravel. The browser doesn't know or care what generated the JSON.</div>
      </div>
      <div class="card">
        <div class="card-label blue">Mobile App</div>
        <div class="card-title">React Native</div>
        <div class="card-text">Native mobile components, not web views. Flexbox layout system with platform-specific styling. Completely independent of backend choice.</div>
      </div>
      <div class="card">
        <div class="card-label blue">Shared Design System</div>
        <div class="card-title">FoodGenie UI Kit</div>
        <div class="card-text">Color tokens, typography scales, spacing values, and component patterns defined once and consumed by both web (Tailwind) and mobile (React Native StyleSheet).</div>
      </div>
    </div>

    <p>The design advantage of the all-JavaScript stack isn't about responsive CSS — it's about <strong>component reuse</strong>. With React (web) + React Native (mobile), you can share business logic components (hooks, state management, API clients, validation) while maintaining platform-specific UI layers. This means your recipe card, inventory list, and meal planner logic work on both platforms from day one.</p>
  </div>

  <!-- SECTION 5: ARCHITECTURE OVERVIEW -->
  <div class="section">
    <div class="section-num">05 — The Complete Picture</div>
    <h2>FoodGenie Unified Architecture</h2>

    <div class="architecture-diagram">
      <pre><span class="layer-label">CLIENT LAYER — ALL TYPESCRIPT</span>

  ┌──────────────────────┐    ┌──────────────────────┐
  │    React Web App      │    │  React Native Mobile  │
  │    (Vite + Tailwind)  │    │  (Expo or bare)       │
  │                       │    │                       │
  │  • Responsive SPA     │    │  • Camera (OCR/scan)  │
  │  • Recipe browser     │    │  • BLE Scale connect  │
  │  • Meal planner       │    │  • Push notifications │
  │  • Real-time updates  │    │  • Offline recipes    │
  └─────────┬─────────────┘    └──────────┬────────────┘
            │                              │
            │   @foodgenie/shared-types     │
            │   @foodgenie/api-client       │
            │   @foodgenie/validation       │
            └──────────┬───────────────────┘
                       │
                  REST + WebSocket
                       │
<span class="layer-label">API LAYER — NODE.JS + TYPESCRIPT</span>

  ┌────────────────────────────────────────────────────┐
  │              Node.js + Express API                  │
  │                                                    │
  │  Routes → Middleware → Services → Repositories     │
  │                                                    │
  │  • Auth (Passport.js + sessions/JWT)               │
  │  • Recipe CRUD + AI parsing (streaming)            │
  │  • Inventory management                            │
  │  • Meal planning engine                            │
  │  • Recipe↔Inventory matching                       │
  │  • Socket.io (household sync)                      │
  │  • BullMQ workers (OCR, email, AI batch)           │
  └────────┬──────┬──────┬──────┬──────┬───────────────┘
           │      │      │      │      │
<span class="layer-label">DATA LAYER</span>

  ┌────────┐ ┌────┐ ┌────────┐ ┌──────┐ ┌────────────┐
  │SQL Svr │ │Redis│ │Meili-  │ │Neo4j │ │Anthropic / │
  │Express │ │     │ │search  │ │(later│ │OpenAI API  │
  │        │ │Cache│ │        │ │)     │ │            │
  │Users   │ │Sess.│ │Recipe  │ │Food  │ │Recipe parse│
  │Recipes │ │Queue│ │search  │ │graph │ │Receipt OCR │
  │Inv.    │ │Rate │ │Ingred. │ │Subs  │ │Ingredient  │
  │Plans   │ │Limit│ │search  │ │      │ │normalizer  │
  └────────┘ └────┘ └────────┘ └──────┘ └────────────┘

  Dev: SQL Server Express         Prod: PostgreSQL (AWS RDS)</pre>
    </div>
  </div>

  <!-- SECTION 6: RISK OF EACH PATH WITH MOBILE -->
  <div class="section">
    <div class="section-num">06 — Updated Risk Matrix With Mobile</div>
    <h2>How Mobile Requirements Shift the Risk Profile</h2>

    <table class="comp-table">
      <thead>
        <tr>
          <th>Risk Factor</th>
          <th>Node.js + React Native</th>
          <th>Laravel + React Native</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>Type safety across stack</strong></td>
          <td><span class="badge best">Unified</span> TypeScript everywhere. Backend ↔ web ↔ mobile share types.</td>
          <td><span class="badge partial">Split</span> PHP types on backend, TypeScript on clients. Two sources of truth.</td>
        </tr>
        <tr>
          <td><strong>BLE scale data flow</strong></td>
          <td><span class="badge best">Seamless</span> ScaleReading type flows from BLE → React Native → API → DB unchanged.</td>
          <td><span class="badge partial">Translation</span> TypeScript ScaleReading must be manually mapped to PHP DTO on API receipt.</td>
        </tr>
        <tr>
          <td><strong>AI streaming to mobile</strong></td>
          <td><span class="badge best">Native</span> SSE/WebSocket streams from Node.js → React Native with shared event types.</td>
          <td><span class="badge partial">Complex</span> Laravel queues AI job → broadcasts via Reverb → React Native listens. More hops.</td>
        </tr>
        <tr>
          <td><strong>Developer context switching</strong></td>
          <td><span class="badge yes">Minimal</span> Same language, same patterns, same tooling (ESLint, Prettier, Jest).</td>
          <td><span class="badge partial">Moderate</span> PHP ↔ TypeScript requires mental model shifts. Different test frameworks, linters.</td>
        </tr>
        <tr>
          <td><strong>API client code sharing</strong></td>
          <td><span class="badge best">Full</span> One <code>@foodgenie/api-client</code> package used by web AND mobile.</td>
          <td><span class="badge yes">Full</span> Same — React Native and React web both consume TypeScript API client.</td>
        </tr>
        <tr>
          <td><strong>Hiring for full stack</strong></td>
          <td><span class="badge yes">Easier</span> "JavaScript/TypeScript developer" covers all three layers.</td>
          <td><span class="badge partial">Harder</span> Need PHP devs for backend AND JavaScript devs for frontend/mobile.</td>
        </tr>
        <tr>
          <td><strong>Monorepo feasibility</strong></td>
          <td><span class="badge best">Natural</span> pnpm workspaces: packages/api + packages/web + packages/mobile + packages/shared</td>
          <td><span class="badge no">Split</span> PHP backend separate from JS monorepo. Two repos, two CI pipelines.</td>
        </tr>
      </tbody>
    </table>
  </div>

  <!-- VERDICT -->
  <div class="section">
    <div class="section-num">07 — Decision</div>
    <h2>The Verdict</h2>

    <div class="verdict">
      <h3>Node.js + Express + React + React Native — The Unified TypeScript Stack</h3>
      <p>The Bluetooth scale requirement is the deciding factor. When you need native device APIs (BLE, camera with fine control, background processing, push notifications), you need React Native. When your mobile framework is React Native and your web framework is React, the natural backend is Node.js — completing an all-TypeScript stack where types, validation, API clients, and business logic are shared across every layer.</p>
      <p>This isn't about Node.js being "better" than Laravel in the abstract. It's about <strong>FoodGenie specifically</strong> — an AI-first platform with IoT hardware integration, real-time household sync, and streaming AI responses — running on a unified type system from Bluetooth peripheral to database.</p>
      <p><strong>The existing Laravel documentation is not wasted.</strong> The architectural patterns (Repository → Service → Controller), the database schema design, the API contracts, and the domain modeling all transfer directly. What changes is the syntax, not the thinking.</p>
    </div>

    <h3>Proposed Final Stack</h3>

    <table class="stack-table">
      <tr>
        <td>Language</td>
        <td>TypeScript</td>
        <td>Everywhere — backend, web, mobile, shared packages</td>
      </tr>
      <tr>
        <td>Backend</td>
        <td>Node.js 20 LTS + Express</td>
        <td>API server, Socket.io, BullMQ workers</td>
      </tr>
      <tr>
        <td>Web Frontend</td>
        <td>React 18 + Vite + Tailwind</td>
        <td>SPA, responsive, real-time via Socket.io-client</td>
      </tr>
      <tr>
        <td>Mobile</td>
        <td>React Native (Expo)</td>
        <td>BLE scale, camera, push, offline — Phase 2</td>
      </tr>
      <tr>
        <td>Database (Dev)</td>
        <td>SQL Server Express</td>
        <td>Already installed, proven with OilDri pattern</td>
      </tr>
      <tr>
        <td>Database (Prod)</td>
        <td>PostgreSQL (AWS RDS)</td>
        <td>Knex.js abstracts the switch</td>
      </tr>
      <tr>
        <td>Query Builder</td>
        <td>Knex.js</td>
        <td>Multi-dialect: SQL Server + PostgreSQL from same code</td>
      </tr>
      <tr>
        <td>Auth</td>
        <td>Passport.js + express-session</td>
        <td>Cookie-based for web, JWT for mobile</td>
      </tr>
      <tr>
        <td>Real-time</td>
        <td>Socket.io</td>
        <td>Household inventory sync, meal plan collaboration</td>
      </tr>
      <tr>
        <td>Job Queue</td>
        <td>BullMQ + Redis</td>
        <td>AI batch processing, email, notifications</td>
      </tr>
      <tr>
        <td>Search</td>
        <td>Meilisearch</td>
        <td>Typo-tolerant recipe & ingredient search</td>
      </tr>
      <tr>
        <td>AI</td>
        <td>Anthropic SDK + OpenAI SDK</td>
        <td>Streaming recipe parsing, ingredient normalization</td>
      </tr>
      <tr>
        <td>Process Mgr</td>
        <td>PM2</td>
        <td>Cluster mode, zero-downtime restarts</td>
      </tr>
      <tr>
        <td>Monorepo</td>
        <td>pnpm workspaces</td>
        <td>packages/api, packages/web, packages/mobile, packages/shared</td>
      </tr>
    </table>

    <div class="callout success">
      <strong>Mobile app timing:</strong> The React Native mobile app is a Phase 2 deliverable. The MVP launches as a web-only SPA. However, the monorepo structure and shared types are established from day one so that the mobile app plugs in cleanly when you're ready. The BLE scale integration comes in Phase 3 alongside the hardware development.
    </div>
  </div>

  <div class="footer">
    <p>FoodGenie Architecture Decision Record — Mobile Strategy & Full-Stack Decision</p>
    <p>Generated February 21, 2026 · Based on FoodGenie project documentation and requirements analysis</p>
  </div>

</div>

</body>
</html>
